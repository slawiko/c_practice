# std::vector

> Имя входного файла: стандартный ввод

> Имя выходного файла: стандартный вывод

> Ограничение по времени: 1 с

> Ограничение по памяти: 256 МБ

Требуется реализовать структуру данных «динамический массив целых чисел», поддерживающую две операции:

* добавить число в конец,
* получить число по индексу или вернуть ошибку, если индекс выходит за пределы массива.

В коде следует реализовать структуру под названием `vector` и четыре функции для работы с ней.

* `void vector_init(struct vector* v);` — инициализировать пустой вектор.
* `bool vector_push_back(struct vector* v, int x);` — добавить число в конец вектора. Функция возвращает результат, прошла ли операция успешно. В случае неуспеха вектор не изменяется, размер остаётся прежним. В коде должны корректно обрабатываться случаи ошибок при выделении памяти и целочисленного переполнения (если новый размер вектора слишком велик).
* `const int* vector_at(const struct vector* v, size_t index);` — вернуть указатель на элемент по индексу (0-based) или вернуть `NULL`, если индекс некорректный (т. е. больше или равен числу ранее успешно добавленных элементов).
* `void vector_free(struct vector* v);` — освободить память.

### Формат входного файла

Одна строка описывает одну операцию.
* `push_back x`. Число `x` имеет тип `int`. При выполнении этой операции ничего выводить не нужно.
* `at i`. Число `i` имеет тип `size_t`. Если индекс попадает в текущие границы вектора, нужно вывести число, которое записано по этому индексу. Иначе нужно вывести строку `out_of_range`.

Гарантируется, что данные на входе корректны (команды — только то две, что описаны; числа входят в диапазоны указанных целых типов и корректно считываются).

### Формат выходного файла

Выведите столько строк, сколько на входе задано операций `at`.

### Пример

|стандартный ввод|стандартный вывод|
|---|---|
|`push_back 10`|`10`|
|`at 0`|`out_of_range`|
|`at 1`|`20`|
|`push_back 20`|`10`|
|`at 1`|`30`|
|`push_back 30`|``|
|`at 0`|``|
|`at 2`|``|

#### Замечание

Для чтения числа в переменную типа `size_t` при помощи `scanf()` используйте спецификатор `%zu`.